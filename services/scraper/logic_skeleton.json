{
  "titleSlug": "longest-alternating-subarray-after-removing-at-most-one-element",
  "content": "You are given an integer array \n\nnums\n\n.\n\nA \n\nsubarray\n\n \n\nnums[l..r]\n\n is \n\nalternating\n\n if one of the following holds:\n\nnums[l] < nums[l + 1] > nums[l + 2] < nums[l + 3] > ...\n\nnums[l] > nums[l + 1] < nums[l + 2] > nums[l + 3] < ...\n\nIn other words, if we compare adjacent elements in the subarray, then the comparisons alternate between \n\nstrictly\n\n greater and \n\nstrictly\n\n smaller.\n\nYou can remove \n\nat most one\n\n element from \n\nnums\n\n. Then, you select an alternating subarray from \n\nnums\n\n.\n\nReturn an integer denoting the \n\nmaximum\n\n \n\nlength\n\n of the alternating subarray you can select.\n\nA subarray of length 1 is considered alternating.\n\n \n\nExample 1:\n\nInput:\n\n \n\nnums = [2,1,3,2]\n\nOutput:\n\n \n\n4\n\nExplanation:\n\nChoose not to remove elements.\n\nSelect the entire array \n\n[\n\n2, 1, 3, 2\n\n]\n\n, which is alternating because \n\n2 > 1 < 3 > 2\n\n.\n\nExample 2:\n\nInput:\n\n \n\nnums = [3,2,1,2,3,2,1]\n\nOutput:\n\n \n\n4\n\nExplanation:\n\nChoose to remove \n\nnums[3]\n\n i.e., \n\n[3, 2, 1, \n\n2\n\n, 3, 2, 1]\n\n. The array becomes \n\n[3, 2, 1, 3, 2, 1]\n\n.\n\nSelect the subarray \n\n[3, \n\n2, 1, 3, 2\n\n, 1]\n\n.\n\nExample 3:\n\nInput:\n\n \n\nnums = [100000,100000]\n\nOutput:\n\n \n\n1\n\nExplanation:\n\nChoose not to remove elements.\n\nSelect the subarray \n\n[100000, \n\n100000\n\n]\n\n.\n\n \n\nConstraints:\n\n2 <= nums.length <= 10\n\n^5\n\n1 <= nums[i] <= 10\n\n^5",
  "topicTags": [
    "Array",
    "Dynamic Programming",
    "Enumeration"
  ],
  "hints": [
    "Define <code>left[i][d]</code> as the maximum length of an alternating subarray ending at index <code>i</code>, where <code>d = 0</code> means the last comparison is <code><</code> and <code>d = 1</code> means the last comparison is <code>></code>. Define <code>right[i][d]</code> similarly for subarrays starting at <code>i</code>.",
    "Fill <code>left</code> from left to right and <code>right</code> from right to left; if adjacent values are equal, the alternating chain must restart since <code>==</code> is invalid.",
    "Try removing each index <code>r</code>: if <code>nums[r - 1] < nums[r + 1]</code>, the two sides can connect with pattern <code>< ></code>, giving length <code>left[r - 1][0] + right[r + 1][1]</code>; if <code>nums[r - 1] > nums[r + 1]</code>, connect with pattern <code>> <</code>, giving <code>left[r - 1][1] + right[r + 1][0]</code>.",
    "Also consider not removing any element by taking the maximum value over all <code>left[i][d]</code>."
  ],
  "sampleTestCase": "[2,1,3,2]\n[3,2,1,2,3,2,1]\n[100000,100000]",
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    int longestAlternating(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public int longestAlternating(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def longestAlternating(self, nums: List[int]) -> int:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def longestAlternating(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestAlternating = function(nums) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function longestAlternating(nums: number[]): number {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public int LongestAlternating(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "int longestAlternating(int* nums, int numsSize) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func longestAlternating(nums []int) int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun longestAlternating(nums: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func longestAlternating(_ nums: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn longest_alternating(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef longest_alternating(nums)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function longestAlternating($nums) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  int longestAlternating(List<int> nums) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def longestAlternating(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec longest_alternating(nums :: [integer]) :: integer\n  def longest_alternating(nums) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec longest_alternating(Nums :: [integer()]) -> integer().\nlongest_alternating(Nums) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (longest-alternating nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
    }
  ]
}